<!doctype html public "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
    <title>Copas - Coroutine Oriented Portable Asynchronous Services for Lua</title>
    <link rel="stylesheet" href="http://www.keplerproject.org/doc.css" type="text/css">
</head>
<body>
<center>
<table border="0" cellspacing="2" cellpadding="2">
<tr>
<td align="center"><a href="http://www.keplerproject.org"><img
border="0" alt="Copas" src="copas.png"></a> </td>
</tr>

<tr>
<td align="center"><big><b>Copas</b></big> </td>
</tr>

<tr>
<td align="center" valign="top">Coroutine Oriented Portable
Asynchronous Services for Lua</td>
</tr>
</table>
</center>

<center>
<small>
<a href="index.html">home</a> &middot;
<a href="license.html">license</a> &middot;
<a href="reference.html">reference</a> &middot;
<strong>examples</strong>
</small>
</center>

<hr>
<h2>Introduction to Copas</h2>

<p>Copas is a dispatcher that can help a lot in the creation of request/response
servers based on
<a href="http://www.cs.princeton.edu/~diego/professional/luasocket/">LuaSocket</a>.</p>
<p>Assuming you know how to implement the desired protocol, the first thing you have
to do is create a server socket to receive the client connections.
To do this you have to bind a host and a port using</p>

<pre class="example">
server = socket.bind(host, port)
</pre>

<p>Then you have to create a handler function that implements the desired protocol.
The handler function will be called with a socket for each client connection
and you can use <code>copas.send()</code> and <code>copas.receive()</code> on that socket to
exchange data with the client.</p>

<p>For example, a simple echo handler would be:</p>

<pre class="example">
function echoHandler(skt)
  while true
    local data = copas.receive(skt)
    if data == "quit" then
      break
    end
    copas.send(skt, data)
  end
end
</pre>

<p>If all you will do with the socket is send and receive data, you may alternatively use
<code>copas.wrap()</code> to let your code more close to the LuaSocket way of life:</p>

<pre class="example">
function echoHandler(skt)
  skt = copas.wrap(skt)
  while true
    local data = skt:receive()
    if data == "quit" then
      break
    end
    skt:send(data)
  end
end
</pre>

<p>To register the server socket and associate it with the corresponding handler we do:</p>
<pre class="example">
copas.addserver(server, EchoHandler)
</pre>

<p>And to start Copas and all the registered servers we call:</p>

<pre class="example">
copas.loop()
</pre>

<p>As long as every handler uses Copas's <code>send</code> and <code>receive</code>,
simultaneous connections will be handled transparently by Copas.</p>

<h2>Why use Copas?</h2>

<p>In a basic LuaSocket server usually there is a dispatcher loop like the one below:</p>

<pre class="example">
server = socket.bind(host, port)
while true
  skt = server:accept()
  handle(skt)
end
</pre>

<p>where <code>handle</code> is a function that implements the server protocol using LuaSocket's
socket functions:</p>

<pre class="example">
function handle(skt)
  ...
  -- gets some data from the client - "the request"
  reqdata = skt:receive(pattern)
  ...
  -- sends some data to the client - "the response"
  skt:send(respdata)
  ...
end
</pre>

<p>
The problem with that approach is that the dispatcher loop is doing a busy wait
and can handle just one connection at a time. To solve the busy waiting we can
use LuaSocket's <code>socket.select()</code>, like in:</p>

<pre class="example">
server = socket.bind(host, port)
reading = {server}
while true
  input = socket.select(reading)
  skt = input:accept()
  handle(skt)
end
</pre>

<p>
While this helps our CPU usage, the server is still accepting only one client
connection at a time. To handle more than one client the server must be able to
multitask, and the solution usually involves some kind of threads.</p>
<p>The dispatcher loop then becomes something like:</p>

<pre class="example">
server = socket.bind(host, port)
reading = {server}
while true
  input = socket.select(reading)
  skt = input:accept()
  newthread(handle(skt))
end
</pre>

<p>
where <code>newthread</code> is able to create a new thread that executes
independently the handler function.</p>

<p>
The use of threads in the new loop solves the multitasking problem but may
create another. Some platforms does not offer multithreading or maybe you
don't want to use threads at all.</p>
<p>
If that is the case, using Lua's coroutines may help a lot, and that's
exactly what Copas does. Copas implements the dispatcher loop using coroutines
so the handlers can multitask without the use of threads.</p>

<h2>Using Copas with an existing server</h2>
<p>
If you already have a running server using some dispatcher like the previous
ones, migrating to Copas is quite simple, usually consisting of just three
steps.</p>
<p>
First each server socket and its handler function have to be registered
with Copas:

<pre class="example">
server = socket.bind(host, port)
copas.addserver(server, handle)
</pre>

<p>Secondly the server handler has to be changed to use Copas. One solution
is to use Copas <code>send</code> and <code>receive</code> functions:</p>

<pre class="example">
function handle(skt)
  ...
  -- gets some data from the client - "the request"
  reqdata = copas.receive(skt, pattern)
  ...
  -- sends some data to the client - "the response"
  copas.send(skt, respdata)
   ...
end
</pre>

<p>the alternative is to wrap the received socket:</p>

<pre class="example">
function handle(skt)
  skt = copas.wrap(skt)
  -- now skt behaves like a LuaSocket socket but uses Copas'
  ...
  -- gets some data from the client - "the request"
  reqdata = skt:receive(pattern)
  ...
  -- sends some data to the client - "the response"
  skt:send(respdata)
   ...
end
</pre>

<p>Finally, to run the dispatcher infinite loop you just call:</p>

<pre class="example">
copas.loop()
</pre>

<p>During the loop Copas' dispatcher accepts connections from clients and
automatically calls the corresponding handler functions.<p>

<hr>
<small>$Id: manual.html,v 1.5 2005/03/11 04:48:07 carregal Exp $</small>
</body>
</html>