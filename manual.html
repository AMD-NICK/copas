<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
    <title>Copas - Coroutine Oriented Portable Asynchronous Services for Lua</title>
    <link rel="stylesheet" href="http://www.keplerproject.org/doc.css" type="text/css">
</head>
<body>
<center>
<table border="0" cellspacing="2" cellpadding="2">
<tr>
<td align="center"><a href="http://www.keplerproject.org"><img
border="0" alt="Copas" src="copas.png"></a> </td>
</tr>

<tr>
<td align="center"><big><b>Copas</b></big> </td>
</tr>

<tr>
<td align="center" valign="top">Coroutine Oriented Portable
Asynchronous Services for Lua</td>
</tr>
</table>
</center>

<center>
<small>
<a href="index.html">home</a> &middot;
<a href="#reference">reference</a> &middot;
<a href="#using">using Copas</a>
</small>
</center>

<hr>
<a name="reference"></a>
<h2>Reference</h2>

<p>Copas functions are separated in two groups. The first one is relative to
the use of the dispatcher:</p>
<ul>
<li>
<b><code>copas.addserver(server, handler, timeout)</code></b>
<br>
Adds a new server and its handler to the dispatcher using an optional timeout.
</li>
<li>
<b><code>copas.loop()</code></b>
<br>
Starts a infinite loop listening to client requests and handling them.
</li>
</ul>

<p>The second group is used by the handlers to exchange data with clients:</p>
<ul>
<li>
<b><code>copas.flush(client)</code></b>
<br>
Flushes a client write buffer.
</li>
<li>
<b><code>copas.receive(client, pattern)</code></b>
<br>
Reads a pattern from a client and yields to the reading set on timeouts.
</li>
<li>
<b><code>copas.send(client, data)</code></b>
<br>
Sends data to a client. The operation is buffered and yields to the writing
set on timeouts.
</li>
<li>
<b><code>copas.wrap (skt)</code></b>
<br>
Wraps a socket to use Copas' methods.
</li>
</ul>

<a name="using"></a> 
<h2>Using Copas</h2>

<p>Copas is a dispatcher that can help a lot the creation of request/response
servers based on
<a href="http://www.cs.princeton.edu/~diego/professional/luasocket/">LuaSocket</a>.
In such servers usually there is a dispatcher loop like:</p>

<pre class="example">
socket.bind(host, port)
while true
  input = socket.select(...)
  skt = input:accept()
  handle(skt)
end
</pre>

<p>and a handler function that implements the server protocol using LuaSocket's
socket functions (<code>receive</code> and <code>send</code>):</p>

<pre class="example">
function handle(skt)
  ...
  skt:receive(...)
  ...
  skt:send(...)
  ...
end
</pre>

<p>The problem with that approach is that the dispatcher loop can handle just
one connection at a time. To solve this the loop must be able to multitask, and
the solution usually involves threads.</p>

<p>The dispatcher loop then becomes something like</p>

<pre class="example">
socket.bind(host, port)
while true
  input = socket.select(...)
  skt = input:accept()
  newthread(handle(skt))
end
</pre>

<p>where <code>newthread</code> is able to create a new thread to independently
execute the protocol handler.</p>

<p>The use of threads in the new loop solves the multitasking problem but creates
another. Some platforms does not offer multithreading and sometimes you don't
want to use threads at all. One solution for this is to use Lua's coroutines,
just like Copas does.</p>

<p>Copas uses coroutines and implements the dispatcher loop. To use Copas loop
you have to register each server and its handler function:

<pre class="example">
server = socket.bind(host, port)
copas.addserver(server, handle)
</pre>

<p>The server handler also has to be changed to use Copas sockets instead of
LuaSocket's:</p>

<pre class="example">
function handle(skt)
  skt = copas.wrap(skt)
  ...
  skt:receive(...)
  ...
  skt:send(...)
  ...
end
</pre>

<p>Finally, to run the dispatcher loop you just call

<pre class="example">
copas.loop()
</pre>

<p>After that call, Copas' dispatcher accepts connections from clients and
calls the corresponding handlers for them automatically.<p>

<hr>
<small>$Id: manual.html,v 1.1 2005/03/06 21:29:35 carregal Exp $</small>
</body>
</html>